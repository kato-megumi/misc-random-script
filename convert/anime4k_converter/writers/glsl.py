"""mpv GLSL hook shader writer (.glsl)."""

from ..ir import Anime4KCNN
from ..utils import (
    SPATIAL_OFFSETS_3x3,
    bias_to_vec4_str,
    conv_tex_name,
    variant_label,
    weight_to_mat4_str,
)


def write_glsl(ir: Anime4KCNN, path: str) -> None:
    """Write IR -> mpv GLSL hook shader."""
    label = variant_label(ir)
    num_feat = ir.num_feat
    n_tex = num_feat // 4
    out = []

    # License header
    out.append(f"// Anime4K CNN x2 Upscale ({label})")
    out.append("// Generated by convert_anime4k.py")
    out.append("")

    # Stack list: last n_stack layers (2-indexed to block_depth-1 for UL)
    stack_start = ir.block_depth - ir.n_stack
    agg_save_prefix = "conv2d_last"

    # ─── Initial conv passes ───
    for t in range(n_tex):
        out_start = t * 4
        tex_name = conv_tex_name(0, t)

        out.append(f"//!DESC Anime4K-v4.0-Upscale-CNN-x2-({label})-Conv-4x3x3x3")
        out.append("//!HOOK MAIN")
        out.append("//!BIND MAIN")
        out.append(f"//!SAVE {tex_name}")
        out.append("//!WIDTH MAIN.w")
        out.append("//!HEIGHT MAIN.h")
        out.append("//!COMPONENTS 4")
        out.append("#define go_0(x_off, y_off) (MAIN_texOff(vec2(x_off, y_off)))")
        out.append("vec4 hook() {")

        first = True
        for ox, oy in SPATIAL_OFFSETS_3x3:
            ky, kx = ox + 1, oy + 1
            mat = weight_to_mat4_str(ir.head_weight, out_start, 0, ky, kx)
            ox_f, oy_f = f"{float(ox):.1f}", f"{float(oy):.1f}"
            op = "vec4 result =" if first else "result +="
            out.append(f"    {op} {mat} * go_0({ox_f}, {oy_f});")
            first = False

        bvec = bias_to_vec4_str(ir.head_bias, out_start)
        out.append(f"    result += {bvec};")
        out.append("    return result;")
        out.append("}")

    # ─── Hidden layer passes ───
    for mid_idx in range(ir.block_depth - 1):
        layer_idx = mid_idx + 1  # output layer
        prev_layer = mid_idx      # input layer
        w = ir.mid_weights[mid_idx]
        b = ir.mid_biases[mid_idx]
        in_channels = w.shape[1]

        for t in range(n_tex):
            out_start = t * 4
            tex_name = conv_tex_name(layer_idx, t)
            prev_ref = conv_tex_name(prev_layer, 0)

            out.append(f"//!DESC Anime4K-v4.0-Upscale-CNN-x2-({label})-Conv-4x3x3x{in_channels}")
            out.append("//!HOOK MAIN")
            for bt in range(n_tex):
                out.append(f"//!BIND {conv_tex_name(prev_layer, bt)}")
            out.append(f"//!SAVE {tex_name}")
            out.append(f"//!WIDTH {prev_ref}.w")
            out.append(f"//!HEIGHT {prev_ref}.h")
            out.append("//!COMPONENTS 4")

            # go defines: positive then negative
            for si in range(n_tex):
                st = conv_tex_name(prev_layer, si)
                out.append(f"#define go_{si}(x_off, y_off) "
                           f"(max(({st}_texOff(vec2(x_off, y_off))), 0.0))")
            if ir.factor == 2:
                for si in range(n_tex):
                    st = conv_tex_name(prev_layer, si)
                    out.append(f"#define go_{n_tex + si}(x_off, y_off) "
                               f"(max(-({st}_texOff(vec2(x_off, y_off))), 0.0))")

            out.append("vec4 hook() {")

            first = True
            # Positive
            for si in range(n_tex):
                in_s = si * 4
                for ox, oy in SPATIAL_OFFSETS_3x3:
                    ky, kx = ox + 1, oy + 1
                    mat = weight_to_mat4_str(w, out_start, in_s, ky, kx)
                    ox_f, oy_f = f"{float(ox):.1f}", f"{float(oy):.1f}"
                    op = "vec4 result =" if first else "result +="
                    out.append(f"    {op} {mat} * go_{si}({ox_f}, {oy_f});")
                    first = False
            # Negative
            if ir.factor == 2:
                for si in range(n_tex):
                    in_s = num_feat + si * 4
                    for ox, oy in SPATIAL_OFFSETS_3x3:
                        ky, kx = ox + 1, oy + 1
                        mat = weight_to_mat4_str(w, out_start, in_s, ky, kx)
                        ox_f, oy_f = f"{float(ox):.1f}", f"{float(oy):.1f}"
                        out.append(f"    result += {mat} * go_{n_tex + si}({ox_f}, {oy_f});")

            bvec = bias_to_vec4_str(b, out_start)
            out.append(f"    result += {bvec};")
            out.append("    return result;")
            out.append("}")

    # ─── Aggregation passes ───
    # Aggregation reads from stacked layers (stack_start..block_depth-1)
    agg_binds = []
    for li in range(ir.n_stack):
        layer = stack_start + li
        for ti in range(n_tex):
            agg_binds.append(conv_tex_name(layer, ti))

    for t in range(3):  # 3 output textures for 12 channels
        out_start = t * 4
        total_in = ir.tail_weight.shape[1]
        save_name = f"{agg_save_prefix}{'_tf' if t == 0 else f'_tf{t}'}"

        out.append(f"//!DESC Anime4K-v4.0-Upscale-CNN-x2-({label})-Conv-4x{ir.tail_kernel}x{ir.tail_kernel}x{total_in}")
        out.append("//!HOOK MAIN")
        for ab in agg_binds:
            out.append(f"//!BIND {ab}")
        out.append(f"//!SAVE {save_name}")
        out.append(f"//!WIDTH {agg_binds[0]}.w")
        out.append(f"//!HEIGHT {agg_binds[0]}.h")
        out.append("//!COMPONENTS 4")

        # g_N defines: per layer group, positive then negative
        g_idx = 0
        for li in range(ir.n_stack):
            for ti in range(n_tex):
                bn = agg_binds[li * n_tex + ti]
                out.append(f"#define g_{g_idx} (max(({bn}_tex({bn}_pos)), 0.0))")
                g_idx += 1
            if ir.factor == 2:
                for ti in range(n_tex):
                    bn = agg_binds[li * n_tex + ti]
                    out.append(f"#define g_{g_idx} (max(-({bn}_tex({bn}_pos)), 0.0))")
                    g_idx += 1

        out.append("vec4 hook() {")

        first = True
        g_idx = 0
        for li in range(ir.n_stack):
            # Positive
            for ti in range(n_tex):
                in_s = li * num_feat * ir.factor + ti * 4
                if ir.tail_kernel == 1:
                    mat = weight_to_mat4_str(ir.tail_weight, out_start, in_s, 0, 0)
                    op = "vec4 result =" if first else "result +="
                    out.append(f"    {op} {mat} * g_{g_idx};")
                    first = False
                g_idx += 1
            # Negative
            if ir.factor == 2:
                for ti in range(n_tex):
                    in_s = li * num_feat * ir.factor + num_feat + ti * 4
                    if ir.tail_kernel == 1:
                        mat = weight_to_mat4_str(ir.tail_weight, out_start, in_s, 0, 0)
                        out.append(f"    result += {mat} * g_{g_idx};")
                    g_idx += 1

        bvec = bias_to_vec4_str(ir.tail_bias, out_start)
        out.append(f"    result += {bvec};")
        out.append("    return result;")
        out.append("}")

    # ─── Depth-to-Space pass ───
    out.append(f"//!DESC Anime4K-v4.0-Upscale-CNN-x2-({label})-Depth-to-Space")
    out.append("//!HOOK MAIN")
    out.append("//!BIND MAIN")
    for t in range(3):
        save_name = f"{agg_save_prefix}{'_tf' if t == 0 else f'_tf{t}'}"
        out.append(f"//!BIND {save_name}")
    out.append("//!SAVE MAIN")
    out.append(f"//!WIDTH {agg_save_prefix}_tf.w 2 *")
    out.append(f"//!HEIGHT {agg_save_prefix}_tf.h 2 *")

    out.append("vec4 hook() {")
    for t in range(3):
        save_name = f"{agg_save_prefix}{'_tf' if t == 0 else f'_tf{t}'}"
        out.append(f"    vec2 f{t} = fract({save_name}_pos * {save_name}_size);")
        out.append(f"    ivec2 i{t} = ivec2(f{t} * vec2(2.0));")
        out.append(f"    float c{t} = {save_name}_tex((vec2(0.5) - f{t}) * "
                   f"{save_name}_pt + {save_name}_pos)[i{t}.y * 2 + i{t}.x];")
    out.append("    float c3 = c2;")
    out.append("    return vec4(c0, c1, c2, c3) + MAIN_tex(MAIN_pos);")
    out.append("}")
    out.append("")

    with open(path, "w") as f:
        f.write("\n".join(out))


__all__ = ["write_glsl"]
